# 스케쥴링 알고리즘

* 스케쥴링 알고리즘 기본



## 프로세스 (process) 란?

* 실행 중인 프로그램은 프로세스라고 함
  * 프로세스 : 메모리에 올려져서, 실행 중인 프로그램
  * 코드 이미지(바이너리) : 실행 파일, 예시) ELF format

> 프로세스라는 용어는 작업, task, job 이라는 용어와 혼용



* 응용 프로그램 =! 프로세스
  * 응용 프로그램은 여러 개의 프로세스로 이루어질 수 있음
* 하나의 응용 프로그램은 여러 개의 프로세스(프로그램)가 상호작용을 하면서 실행될 수도 있음

> 간단한 C/C++ 프로그램을 만든다면 -> 하나의 프로세스
>
> 여러 프로그램을 만들어서, 서로 통신하면서 프로그램을 작성할 수도 있음(IPC기법)



## 스케쥴러와 프로세스

* 누가 프로세스 실행을 관리할까? 
  * 스케쥴러



### 스케쥴링 알고리즘

> 어느 순서대로 프로세스를 실행시킬까?

* 목표
  * 시분할 시스템 예시) 프로세스 응답 시간을 가능한 짧게
  * 멀티 프로그래밍 예시) CPU 활용도를 최대로 높혀서, 프로세스를 빨리 실행



#### FIFO(First In First Out) 스케쥴러

> ''프로세스가 저장매체를 읽는다든지, 프린팅을 한다든지 하는 작업 없이, 쭉 CPU를 처음부터 끝까지 사용한다''라고 가정!

* 가장 간단한 스케쥴러 (배치 처리 시스템)
* FCFS (First Come First Served) 스케쥴러
* QUEUE 자료구조를 사용



#### 최단 작업 우선(SJF) 스케쥴러

* SJF(Shortest Job First) 스케쥴러
  * 가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행을 시키는 알고리즘



#### :bulb:

* RealTime OS(RTOS) : 응용 프로그램 실시간 성능 보장을 목표로 하는 OS
  * 정확하게 프로그램 시작, 완료 시간을 보장
  * Hardware RTOS, Software RTOS
* General Purpose OS(GPOS) : 프로세스 실행시간에 민감하지 않고, 일반적인 목적으로 사용되는 OS
  * Windows, Linux 등



#### 우선순위 기반 스케쥴러

* Priority-Based 스케쥴러
  * 정적 우선순위
    * 프로세스마다 우선순위를 미리 지정
  * 동적 우선순위
    * 스케쥴러가 상황에 따라 우선순위를 동적으로 변경



#### Round Robin 스케쥴러

* **시분할 시스템**을 기반으로 해서 실행시간을 쪼개 CPU에서 프로세스를 실행시키는 알고리즘
  * 프로세스가 수행이 완료가 되지않으면 Round Robin ready Queue로 다시 넣어서 순서를 기다리게 하는 형식 (시분할 시스템을 생각하면 됨)



## 프로세스 상태와 스케쥴링



### 멀티 프로그래밍과 Wait

* 멀티 프로그래밍 : CPU 활용도를 극대화하는 스케쥴링 알고리즘
* Wait : 간단히 저장매체로부터 파일 읽기를 기다리는 시간으로 가정



### 프로세스 상태

* running state: 현재 CPU에서 실행 상태
* ready state: CPU에서 실행 가능 상태(실행 대기 상태)
* block state: 특정 이벤트 발생 대기 상태(예시:프린팅이 다 되었다!) 

> +프로세스 생성(new)
>
> +종료(exit)



`1번` Process bloks for input(특정 이벤트 대기)

`2번` Scheduler picks another process

`3번` Scheduler picks this process

`4번` Process becomes available



> 프로세스 running 상태에서 파일 읽기 작업을 수행하려면  특정 이벤트 대기 block 상태로 변한다`1번`
>
> 파일 읽기가 완료되면 ready 상태가 된다.`4번`
>
> 스케쥴러가 해당 프로세스를 선택하면 running 상태로 바꿔준다`2번`
>
> 시분할 시스템 경우 running 상태에서 ready 상태로 바꿔줄 수 있다.`3번`



* ready 상태의 프로세스가 여러 개라면 어떤 프로세스를 골라야 할까?

### 프로세스 상태기반 스케쥴링 알고리즘 기본

* 프로세스 상태기반으로 알고리즘으로 만든다면 프로세스를 3가지 상태의 `Queue`로 만들어서 `Queue` 에 넣고 빼는 방식의 알고리즘이 기본

  `Ready State Queue` 

  `Running State Queue`

  `Block State Queue` 

> CPU가 아무것도 하지 않는 상태 : `idle`



### 선점형과 비선점형 스케쥴러

* 선점형 스케쥴러 (Preemptive Scheduling)

  * 하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 차지할 수 있음. 

  > 스케쥴러가 강제적으로 실행 중인 프로세스를 중단시키고 다른 프로세스를 CPU에서 실행하도록 하는 것

* 비선점형 스케쥴러 (Non-preemptive Scheduilng)

  * 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음.

  > 프로세스가 block 상태나 end 상태가 되어야만 다르 프로세스 실행 가능. 



#### 선점형과 비선점형 스케쥴러의 차이

* 비선점형 : 프로세스가 자발적으로 blocking 상태로 들어가거나, 실행이 끝났을 때만, 다른 프로세스로 교체 가능
  * 응답시간이 길어질 수 있음
* 선점형 : 프로세스 running 중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체 가능 
  * 응답시간이 짧아질 수 있음
  * 요즘의 스케쥴러는 선점형 스케쥴러의 형태 



## 스케쥴러 구분 (정책, policy)

* FIFO(FCFS), SJF, Priority-based 는 어떤 프로세스를 먼저 실행시킬지에 대한 알고리즘 (비선점형 스케쥴러)
* RoundRobin은 시분할 시스템을 위한 기본 알고리즘 (선점형 스케쥴러)



* 스케쥴러 정책 == 스케쥴링 알고리즘 조합 
  * 예시) 
    * 1. 우선순위 기반(정적)
      2. 선점형
      3. 시분할
      4. 프로세스 상태

> 랙? 마우스/키보드 반응이 느린 경우?
>
> 스케쥴러가 해결해야하는 이슈
>
> 다양하고 복잡한 스케쥴링 알고리즘 필요
>
> * 리눅스 스케쥴러 : O(1), CFS와 같이 다양한 방식으로 변경 시도 중
>   * 인터렉티브, IO, CPU 중심 프로세스로 미리 구분할 수 있다면 보다 개선된 스케쥴링이 가능함
